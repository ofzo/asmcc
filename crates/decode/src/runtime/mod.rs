use self::decoder::WasmModule;

pub mod constants;
pub mod decoder;
pub mod section;

#[derive(Debug, Default)]
pub struct OxygenRuntime {
    pub modes: Vec<WasmModule>,
}

impl OxygenRuntime {
    pub fn load(&mut self, buf: Vec<u8>) -> anyhow::Result<()> {
        let mut m = WasmModule::default(buf.to_vec());
        m.decode()?;
        self.modes.push(m);
        Ok(())
    }
}

#[test]
fn test_parse() {
    let buf = vec![
        0x00, 0x61, 0x73, 0x6d, // magic = \0asm
        0x01, 0x00, 0x00, 0x00, // version  = 1 (little endian)
        //
        0x01, 0x07, 0x01, // type section
        0x60, 0x02, 0x7f, 0x7f, 0x01, 0x7f, // func type 1
        //
        0x03, 0x05, 0x04, 0x00, 0x00, 0x00, 0x00, // func section
        //
        0x05, 0x03, 0x01, 0x00, 0x01, // memory
        //
        0x07, 0x19, 0x04, // export section
        0x03, 0x61, 0x64, 0x64, 0x00, 0x00, // export 1
        0x03, 0x73, 0x75, 0x62, 0x00, 0x01, // export 2
        0x03, 0x6d, 0x75, 0x6c, 0x00, 0x02, // export 3
        0x03, 0x64, 0x69, 0x76, 0x00, 0x03, // export 4
        //
        0x0a, 0x21, 0x04, // code sectiion
        0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b, // func body 1
        0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6b, 0x0b, // func body 2
        0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6c, 0x0b, // func body 3
        0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6e, 0x0b, // func body 4
        //
        0x0b, 0x07, 0x01, 0x00, 0x41, 0x00, 0x0b, 0x01, 0x61, // data section
    ];
    let mut wasm = decoder::WasmModule::default(buf);
    wasm.decode().unwrap();
    println!("{}", wasm);

    assert_eq!(wasm.version, 0x01);
    assert_eq!(wasm.section.types.type_count, 0x01);
    assert_eq!(wasm.section.func.func_count, 0x04);
    assert_eq!(wasm.section.export.export_count, 0x04);
    assert_eq!(wasm.section.code.body_count, 0x04);
}
